# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(2,.7,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(2,.3,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1,.7,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1.5,.7,0.5), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=3, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1.5,2,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(GGally)
library(lmerTest)
library(glmnet)
library(dplyr)
library(ggplot2)
library(GGally)
library(lmerTest)
library(glmnet)
data_clean <- read.csv(file='./data/listings_clean.csv')
data_scaled <- as.data.frame(scale(data_clean))
# train test split
set.seed(0)
train_indices <- sample(1:nrow(data_scaled), 0.8 * nrow(data_scaled))
train_data <- data_scaled[train_indices,]
test_data <- data_scaled[-train_indices,]
full_model <- lm(price_log ~ ., data = train_data)
fit1 <- lm(price_log ~ ., data = train_data)
fit2 <- lm(price_log ~ 1, data = train_data)
forward_model <- step(fit2, direction = "forward", scope=list(upper=fit1, lower=fit2), trace=0)
summary(forward_model)
confint(forward_model, level = 0.95)
data_clean <- read.csv(file='./data/listings_clean.csv')
data_scaled <- as.data.frame(scale(data_clean))
# train test split
set.seed(0)
train_indices <- sample(1:nrow(data_scaled), 0.8 * nrow(data_scaled))
train_data <- data_scaled[train_indices,]
test_data <- data_scaled[-train_indices,]
full_model <- lm(price_log ~ ., data = train_data)
fit1 <- lm(price_log ~ ., data = train_data)
fit2 <- lm(price_log ~ 1, data = train_data)
forward_model <- step(fit2, direction = "forward", scope=list(upper=fit1, lower=fit2), trace=0)
summary(forward_model)
backward_model <- step(fit1, direction = "backward", trace=0)
summary(backward_model)
# lasso
# lambda grid
grid = 10^seq(2, -4, length = 100)
# split data
x_train <- model.matrix(price_log ~ ., train_data)[,-1]  # removing the intercept
y_train <- train_data$price_log
x_test <- model.matrix(price_log ~ ., test_data)[,-1]
y_test <- test_data$price_log
lasso_cv <- cv.glmnet(x_train, y_train, alpha = 1, lambda = grid)
lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lasso_cv$lambda.min)
# RMSE
rmse <- function(predicted, actual) {
sqrt(mean((predicted - actual)^2))
}
# R_squared
r_squared <- function(predicted, actual) {
1 - (sum((actual - predicted)^2) / sum((actual - mean(actual))^2))
}
# Full model
full_pred <- predict(full_model, test_data)
full_rmse <- rmse(full_pred, test_data$price_log)
full_r_squared <- r_squared(full_pred, test_data$price_log)
# Forward selection
forward_pred <- predict(forward_model, newdata = test_data)
forward_rmse <- rmse(forward_pred, test_data$price_log)
forward_r_squared <- r_squared(forward_pred, test_data$price_log)
# Backward selection
backward_pred <- predict(backward_model, newdata = test_data)
backward_rmse <- rmse(backward_pred, test_data$price_log)
backward_r_squared <- r_squared(backward_pred, test_data$price_log)
# Lasso
lasso_pred <- predict(lasso_model, s = lasso_cv$lambda.min, newx = x_test)
lasso_rmse <- rmse(lasso_pred, y_test)
lasso_r_squared <- r_squared(lasso_pred, y_test)
# Ridge
ridge_pred <- predict(ridge_model, s = ridge_cv$lambda.min, newx = x_test)
# ridge
ridge_cv <- cv.glmnet(x_train, y_train, alpha = 0, lambda = grid)
ridge_model <- glmnet(x_train, y_train, alpha = 0, lambda = ridge_cv$lambda.min)
# RMSE
rmse <- function(predicted, actual) {
sqrt(mean((predicted - actual)^2))
}
# R_squared
r_squared <- function(predicted, actual) {
1 - (sum((actual - predicted)^2) / sum((actual - mean(actual))^2))
}
# Full model
full_pred <- predict(full_model, test_data)
full_rmse <- rmse(full_pred, test_data$price_log)
full_r_squared <- r_squared(full_pred, test_data$price_log)
# Forward selection
forward_pred <- predict(forward_model, newdata = test_data)
forward_rmse <- rmse(forward_pred, test_data$price_log)
forward_r_squared <- r_squared(forward_pred, test_data$price_log)
# Backward selection
backward_pred <- predict(backward_model, newdata = test_data)
backward_rmse <- rmse(backward_pred, test_data$price_log)
backward_r_squared <- r_squared(backward_pred, test_data$price_log)
# Lasso
lasso_pred <- predict(lasso_model, s = lasso_cv$lambda.min, newx = x_test)
lasso_rmse <- rmse(lasso_pred, y_test)
lasso_r_squared <- r_squared(lasso_pred, y_test)
# Ridge
ridge_pred <- predict(ridge_model, s = ridge_cv$lambda.min, newx = x_test)
ridge_rmse <- rmse(ridge_pred, y_test)
ridge_r_squared <- r_squared(lasso_pred, y_test)
results <- data.frame(
Model = c("Full", "Forward", "Backward", "Lasso", "Ridge"),
RMSE = c(full_rmse, forward_rmse, backward_rmse, lasso_rmse, ridge_rmse),
R_squared = c(full_r_squared, forward_r_squared, backward_r_squared, lasso_r_squared, ridge_r_squared)
)
print(results)
?geom_point
predictions <- data.frame(y_true = test_data$price_log, y_pred = predict(forward_model, newdata = test_data))
library(ggplot2)
ggplot(predictions, aes(x = y_true, y = y_pred)) +
geom_point() +
geom_abline(color = "#F08080", size = 1)
# Plot predicted vs actual values with a regression line
ggplot(predictions, aes(x = y_true, y = y_pred)) +
geom_point(color = "#FFC0CB", alpha = 0.5) +
geom_abline(intercept = 0, slope = 1, color = "#FF69B4", linetype = "dashed") +
labs(x = "True Values", y = "Predicted Values") +
theme_minimal() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(colour = "black"),
legend.position = "none",
text = element_text(size = 12, family = "Helvetica"))
predictions <- data.frame(y_true = test_data$price_log, y_pred = predict(forward_model, newdata = test_data))
library(ggplot2)
ggplot(predictions, aes(x = y_true, y = y_pred)) +
geom_point() +
geom_abline(color = "#F08080", size = 1)
# Plot predicted vs actual values with a regression line
ggplot(predictions, aes(x = y_true, y = y_pred)) +
geom_point(color = "#FFC0CB", alpha = 0.7) +
geom_abline(intercept = 0, slope = 1, color = "#FF69B4", linetype = "dashed") +
labs(x = "True Values", y = "Predicted Values") +
theme_minimal() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(colour = "black"),
legend.position = "none",
text = element_text(size = 12, family = "Helvetica"))
full_model$call$formula
summary(full_model)
knitr::opts_chunk$set(echo = TRUE)
data_EDA <- read.csv(file='./data/listings_EDA.csv')
type_entire <- data_EDA$room_typeEntire.home.apt
price_log <- data_EDA$price_log
# put neighborhood into numbers
neighborhood_name <- as.vector(data_EDA$neighbourhood_group_cleansed)
uniq <- unique(neighborhood_name)
J <- length(uniq)
neighborhood <- rep (NA, J)
for (i in 1:J){
neighborhood[neighborhood_name==uniq[i]] <- i
}
# Complete pooling regression
lm_pooled <- lm (price_log ~ type_entire)
# Varying intercept regression
M1 <- lmer (price_log ~ type_entire + (1 | neighborhood))
a.hat.M1 <- coef(M1)$neighborhood[,1]                # 1st column is the intercept
b.hat.M1 <- coef(M1)$neighborhood[,2]                # 2nd element is the slope
## Varying intercept & slopes regression
M2 <- lmer (price_log ~ type_entire + (1 + type_entire | neighborhood))
a.hat.M2 <- fixef(M2)[1] + ranef(M2)$neighborhood[,1]
b.hat.M2 <- fixef(M2)[2] + ranef(M2)$neighborhood[,2]
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1.1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1.1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=10, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
par(mar = c(3, 3, 1, 1) + 0.1)
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=12, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
par(mar = c(3, 3, 1, 1) + 0.1)
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(GGally)
library(lmerTest)
library(glmnet)
data_clean <- read.csv(file='./data/listings_clean.csv')
data_scaled <- as.data.frame(scale(data_clean))
# train test split
set.seed(0)
train_indices <- sample(1:nrow(data_scaled), 0.8 * nrow(data_scaled))
train_data <- data_scaled[train_indices,]
test_data <- data_scaled[-train_indices,]
full_model <- lm(price_log ~ ., data = train_data)
fit1 <- lm(price_log ~ ., data = train_data)
fit2 <- lm(price_log ~ 1, data = train_data)
forward_model <- step(fit2, direction = "forward", scope=list(upper=fit1, lower=fit2), trace=0)
summary(forward_model)
backward_model <- step(fit1, direction = "backward", trace=0)
summary(backward_model)
# lasso
# lambda grid
grid = 10^seq(2, -4, length = 100)
# split data
x_train <- model.matrix(price_log ~ ., train_data)[,-1]  # removing the intercept
y_train <- train_data$price_log
x_test <- model.matrix(price_log ~ ., test_data)[,-1]
y_test <- test_data$price_log
lasso_cv <- cv.glmnet(x_train, y_train, alpha = 1, lambda = grid)
lasso_model <- glmnet(x_train, y_train, alpha = 1, lambda = lasso_cv$lambda.min)
# ridge
ridge_cv <- cv.glmnet(x_train, y_train, alpha = 0, lambda = grid)
ridge_model <- glmnet(x_train, y_train, alpha = 0, lambda = ridge_cv$lambda.min)
# RMSE
rmse <- function(predicted, actual) {
sqrt(mean((predicted - actual)^2))
}
# R_squared
r_squared <- function(predicted, actual) {
1 - (sum((actual - predicted)^2) / sum((actual - mean(actual))^2))
}
# Full model
full_pred <- predict(full_model, test_data)
full_rmse <- rmse(full_pred, test_data$price_log)
full_r_squared <- r_squared(full_pred, test_data$price_log)
# Forward selection
forward_pred <- predict(forward_model, newdata = test_data)
forward_rmse <- rmse(forward_pred, test_data$price_log)
forward_r_squared <- r_squared(forward_pred, test_data$price_log)
# Backward selection
backward_pred <- predict(backward_model, newdata = test_data)
backward_rmse <- rmse(backward_pred, test_data$price_log)
backward_r_squared <- r_squared(backward_pred, test_data$price_log)
# Lasso
lasso_pred <- predict(lasso_model, s = lasso_cv$lambda.min, newx = x_test)
lasso_rmse <- rmse(lasso_pred, y_test)
lasso_r_squared <- r_squared(lasso_pred, y_test)
# Ridge
ridge_pred <- predict(ridge_model, s = ridge_cv$lambda.min, newx = x_test)
ridge_rmse <- rmse(ridge_pred, y_test)
ridge_r_squared <- r_squared(lasso_pred, y_test)
results <- data.frame(
Model = c("Full", "Forward", "Backward", "Lasso", "Ridge"),
RMSE = c(full_rmse, forward_rmse, backward_rmse, lasso_rmse, ridge_rmse),
R_squared = c(full_r_squared, forward_r_squared, backward_r_squared, lasso_r_squared, ridge_r_squared)
)
print(results)
# full model
full_coef_abs <- abs(coef(full_model)[-1]) # Remove intercept
full_coef_importance <- data.frame(Feature = names(full_coef_abs),
Importance = full_coef_abs, row.names = NULL)
full_coef_importance <- full_coef_importance %>% arrange(desc(Importance))
print(full_coef_importance)
# forward
forward_coef_abs <- abs(coef(forward_model)[-1])
forward_coef_importance <- data.frame(Feature = names(forward_coef_abs),
Importance = forward_coef_abs,
row.names = NULL)
forward_coef_importance <- forward_coef_importance %>% arrange(desc(Importance))
print(forward_coef_importance)
# backward
backward_coef_abs <- abs(coef(backward_model)[-1])
backward_coef_importance <- data.frame(Feature = names(backward_coef_abs),
Importance = backward_coef_abs, row.names = NULL)
backward_coef_importance <- backward_coef_importance %>% arrange(desc(Importance))
print(backward_coef_importance)
# lasso
lasso_coef_abs <- abs(coef(lasso_model)[-1])
lasso_importance <- data.frame(Feature = colnames(x_train), Importance = lasso_coef_abs,
row.names = NULL)
lasso_importance <- lasso_importance %>% arrange(desc(Importance))
print(lasso_importance)
# Remove intercept
ridge_coef_abs <- abs(coef(ridge_model)[-1]) # Remove intercept
ridge_importance <- data.frame(Feature = colnames(x_train), Importance = ridge_coef_abs,
row.names = NULL)
ridge_importance <- ridge_importance %>% arrange(desc(Importance))
print(ridge_importance)
forward_r_squared - backward_r_squared
forward_rmse - backward_rmse
knitr::opts_chunk$set(echo = TRUE)
data_EDA <- read.csv(file='./data/listings_EDA.csv')
type_entire <- data_EDA$room_typeEntire.home.apt
price_log <- data_EDA$price_log
# put neighborhood into numbers
neighborhood_name <- as.vector(data_EDA$neighbourhood_group_cleansed)
uniq <- unique(neighborhood_name)
J <- length(uniq)
neighborhood <- rep (NA, J)
for (i in 1:J){
neighborhood[neighborhood_name==uniq[i]] <- i
}
# Complete pooling regression
lm_pooled <- lm (price_log ~ type_entire)
# Varying intercept regression
M1 <- lmer (price_log ~ type_entire + (1 | neighborhood))
a.hat.M1 <- coef(M1)$neighborhood[,1]                # 1st column is the intercept
b.hat.M1 <- coef(M1)$neighborhood[,2]                # 2nd element is the slope
## Varying intercept & slopes regression
M2 <- lmer (price_log ~ type_entire + (1 + type_entire | neighborhood))
a.hat.M2 <- fixef(M2)[1] + ranef(M2)$neighborhood[,1]
b.hat.M2 <- fixef(M2)[2] + ranef(M2)$neighborhood[,2]
# plot
n <- length(price_log)
x.jitter <- type_entire + runif(n,-.05,.05)
display8 <- c (1,2,3,4,5)
y.range <- range (price_log[!is.na(match(neighborhood,display8))])
png(file='./plots/multilevel.png',width=12, height=2.5, units='in', pointsize = 14, res=350)
par (mfrow=c(1,5))
par(mar = c(3, 3, 1, 1) + 0.1)
for (j in display8){
plot (x.jitter[neighborhood==j], price_log[neighborhood==j], xlim=c(-.05,1.05), ylim=y.range,
xlab="entire home apt", ylab="log price", main=uniq[j], cex.lab=1,
cex.axis=1, pch=20, mgp=c(1.5,.7,0), xaxt="n", yaxt="n", cex.main=1)
axis (1, c(0,1), mgp=c(2,.7,0), cex.axis=1)
axis (2, c(2,4,6,8,10), mgp=c(2,.7,0), cex.axis=1)
curve (coef(lm_pooled)[1] + coef(lm_pooled)[2]*x, lty=2, col="gray10", add=TRUE)
curve (a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="red", add=TRUE)
curve (a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="blue", add=TRUE)
}
dev.off()
summary(M1)
M1
summary(M2)
